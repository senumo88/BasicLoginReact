{"ast":null,"code":"import _slicedToArray from \"H:\\\\React\\\\login\\\\react-protected-route\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isDateObject = data => data instanceof Date;\n\nvar isNullOrUndefined = value => value == null;\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);\n\nvar getControllerValue = event => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\n\nvar getNodeParentName = name => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => getNodeParentName(name) === current);\n\nvar compact = value => value.filter(Boolean);\n\nvar isUndefined = val => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\n  if (isObject(obj) && path) {\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n    return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n  }\n\n  return undefined;\n};\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nvar omit = (source, key) => {\n  const copy = Object.assign({}, source);\n  delete copy[key];\n  return copy;\n};\n\nconst FormContext = React.createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => React.useContext(FormContext);\n\nconst FormProvider = props => React.createElement(FormContext.Provider, {\n  value: omit(props, 'children')\n}, props.children);\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled ? new Proxy(formState, {\n  get: (obj, prop) => {\n    if (prop in obj) {\n      if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n        readFormStateRef.current[prop] = isRoot ? VALIDATION_MODE.all : true;\n      }\n\n      localReadFormStateRef && (localReadFormStateRef.current[prop] = true);\n      return obj[prop];\n    }\n\n    return undefined;\n  }\n}) : formState;\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, readFormStateRef, isRoot) => {\n  const formState = omit(formStateData, 'name');\n  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(readFormStateRef).length || Object.keys(formState).find(key => readFormStateRef[key] === (isRoot ? VALIDATION_MODE.all : true));\n};\n\nvar convertToArrayPayload = value => Array.isArray(value) ? value : [value];\n\nvar isWeb = typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined' && typeof document !== 'undefined';\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== 'undefined';\n\nfunction useFormState(props) {\n  const _ref = props || {},\n        control = _ref.control,\n        name = _ref.name;\n\n  const methods = useFormContext();\n\n  const _ref2 = control || methods.control,\n        formStateRef = _ref2.formStateRef,\n        subjectsRef = _ref2.subjectsRef,\n        readFormStateRef = _ref2.readFormStateRef;\n\n  const nameRef = React.useRef(name);\n  nameRef.current = name;\n\n  const _React$useState = React.useState(formStateRef.current),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        formState = _React$useState2[0],\n        updateFormState = _React$useState2[1];\n\n  const readFormState = React.useRef({\n    isDirty: false,\n    dirtyFields: false,\n    touchedFields: false,\n    isValidating: false,\n    isValid: false,\n    errors: false\n  });\n  React.useEffect(() => {\n    const formStateSubscription = subjectsRef.current.state.subscribe({\n      next: formState => (!nameRef.current || !formState.name || convertToArrayPayload(nameRef.current).includes(formState.name)) && shouldRenderFormState(formState, readFormState.current) && updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState))\n    });\n    return () => formStateSubscription.unsubscribe();\n  }, []);\n  return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\n}\n\nfunction useController({\n  name,\n  rules,\n  defaultValue,\n  control,\n  shouldUnregister\n}) {\n  const methods = useFormContext();\n\n  const _ref3 = control || methods.control,\n        defaultValuesRef = _ref3.defaultValuesRef,\n        register = _ref3.register,\n        fieldsRef = _ref3.fieldsRef,\n        unregister = _ref3.unregister,\n        namesRef = _ref3.namesRef,\n        subjectsRef = _ref3.subjectsRef,\n        shouldUnmount = _ref3.shouldUnmount,\n        inFieldArrayActionRef = _ref3.inFieldArrayActionRef;\n\n  const field = get(fieldsRef.current, name);\n\n  const _React$useState3 = React.useState(field && field._f && !isUndefined(field._f.value) ? field._f.value : isUndefined(get(defaultValuesRef.current, name)) ? defaultValue : get(defaultValuesRef.current, name)),\n        _React$useState4 = _slicedToArray(_React$useState3, 2),\n        value = _React$useState4[0],\n        setInputStateValue = _React$useState4[1];\n\n  const _register = register(name, Object.assign(Object.assign({}, rules), {\n    value\n  })),\n        onChange = _register.onChange,\n        onBlur = _register.onBlur,\n        ref = _register.ref;\n\n  const formState = useFormState({\n    control: control || methods.control,\n    name\n  });\n  React.useEffect(() => {\n    const controllerSubscription = subjectsRef.current.control.subscribe({\n      next: data => (!data.name || name === data.name) && setInputStateValue(get(data.values, name))\n    });\n    return () => {\n      controllerSubscription.unsubscribe();\n      const shouldUnmountField = shouldUnmount || shouldUnregister;\n\n      if (isNameInFieldArray(namesRef.current.array, name) ? shouldUnmountField && !inFieldArrayActionRef.current : shouldUnmountField) {\n        unregister(name);\n      } else {\n        const field = get(fieldsRef.current, name);\n\n        if (field && field._f) {\n          field._f.mount = false;\n        }\n      }\n    };\n  }, [name]);\n  return {\n    field: {\n      onChange: event => {\n        const value = getControllerValue(event);\n        setInputStateValue(value);\n        onChange({\n          target: {\n            value,\n            name: name\n          },\n          type: EVENTS.CHANGE\n        });\n      },\n      onBlur: () => {\n        onBlur({\n          target: {\n            name: name\n          },\n          type: EVENTS.BLUR\n        });\n      },\n      name,\n      value,\n      ref: elm => elm && ref({\n        focus: () => elm.focus && elm.focus(),\n        setCustomValidity: message => elm.setCustomValidity(message),\n        reportValidity: () => elm.reportValidity()\n      })\n    },\n    formState,\n    fieldState: {\n      invalid: !!get(formState.errors, name),\n      isDirty: !!get(formState.dirtyFields, name),\n      isTouched: !!get(formState.touchedFields, name),\n      error: get(formState.errors, name)\n    }\n  };\n}\n\nconst Controller = props => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {\n  types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), {\n    [type]: message || true\n  })\n}) : {};\n\nvar isKey = value => /^\\w*$/.test(value);\n\nvar stringToPath = input => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\n  for (const key of fieldsNames || Object.keys(fields)) {\n    const field = get(fields, key);\n\n    if (field) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n\n      if (_f && callback(_f.name)) {\n        if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n          break;\n        } else if (_f.refs) {\n          _f.refs[0].focus();\n\n          break;\n        }\n      } else if (isObject(current)) {\n        focusFieldBy(current, callback);\n      }\n    }\n  }\n};\n\nconst getFieldsValues = (fieldsRef, output = {}) => {\n  for (const name in fieldsRef.current) {\n    const field = fieldsRef.current[name];\n\n    if (field && !isNullOrUndefined(output)) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n      set(output, name, _f && _f.ref ? _f.ref.disabled || _f.refs && _f.refs.every(ref => ref.disabled) ? undefined : _f.value : Array.isArray(field) ? [] : {});\n      current && getFieldsValues({\n        current\n      }, output[name]);\n    }\n  }\n\n  return output;\n};\n\nvar generateId = () => {\n  const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nvar mapIds = (values = [], keyName) => values.map(value => Object.assign({\n  [keyName]: value && value[keyName] || generateId()\n}, value));\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2) || isDateObject(object1) || isDateObject(object2)) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        !isNullOrUndefined(defaultValues) && deepEqual(get(defaultValues[index] || {}, key), values[index][key]) ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), {\n          [key]: true\n        });\n      }\n    }\n\n    parentNode && !dirtyFields.length && delete parentNode[parentName];\n  }\n\n  return dirtyFields;\n}\n\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\n  return [...data, ...convertToArrayPayload(value)];\n}\n\nvar fillEmptyArray = value => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...convertToArrayPayload(value), ...data.slice(index)];\n}\n\nvar moveArrayAt = (data, from, to) => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nfunction prepend(data, value) {\n  return [...convertToArrayPayload(value), ...data];\n}\n\nfunction removeAtIndexes(data, indexes) {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  data[indexA] = [data[indexB], data[indexB] = data[indexA]][0];\n};\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst useFieldArray = ({\n  control,\n  name,\n  keyName = 'id',\n  shouldUnregister\n}) => {\n  const methods = useFormContext();\n  const focusNameRef = React.useRef('');\n  const isMountedRef = React.useRef(false);\n\n  const _ref4 = control || methods.control,\n        getIsDirty = _ref4.getIsDirty,\n        namesRef = _ref4.namesRef,\n        fieldsRef = _ref4.fieldsRef,\n        defaultValuesRef = _ref4.defaultValuesRef,\n        formStateRef = _ref4.formStateRef,\n        subjectsRef = _ref4.subjectsRef,\n        readFormStateRef = _ref4.readFormStateRef,\n        updateIsValid = _ref4.updateIsValid,\n        fieldArrayDefaultValuesRef = _ref4.fieldArrayDefaultValuesRef,\n        unregister = _ref4.unregister,\n        shouldUnmount = _ref4.shouldUnmount,\n        inFieldArrayActionRef = _ref4.inFieldArrayActionRef,\n        setValues = _ref4.setValues,\n        register = _ref4.register;\n\n  const _React$useState5 = React.useState(mapIds((get(fieldsRef.current, name) && isMountedRef.current ? get(getFieldsValues(fieldsRef), name) : get(fieldArrayDefaultValuesRef.current, getNodeParentName(name)) ? get(fieldArrayDefaultValuesRef.current, name) : get(defaultValuesRef.current, name)) || [], keyName)),\n        _React$useState6 = _slicedToArray(_React$useState5, 2),\n        fields = _React$useState6[0],\n        setFields = _React$useState6[1];\n\n  set(fieldArrayDefaultValuesRef.current, name, [...fields]);\n  namesRef.current.array.add(name);\n\n  const omitKey = fields => fields.map((field = {}) => omit(field, keyName));\n\n  const getCurrentFieldsValues = () => {\n    const values = get(getFieldsValues(fieldsRef), name, []);\n    return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => Object.assign(Object.assign({}, item), values[index])), keyName);\n  };\n\n  const getFocusFieldName = (index, options) => options && !options.shouldFocus ? options.focusName || \"\".concat(name, \".\").concat(options.focusIndex, \".\") : \"\".concat(name, \".\").concat(index, \".\");\n\n  const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\n\n  const cleanup = ref => !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\n    inFieldArrayActionRef.current = true;\n\n    if (get(fieldsRef.current, name)) {\n      const output = method(get(fieldsRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldsRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touchedFields && get(formStateRef.current.touchedFields, name)) {\n      const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.touchedFields, name, output);\n      cleanup(formStateRef.current.touchedFields);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n      updatedFieldArrayValues && set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    subjectsRef.current.state.next({\n      isDirty: getIsDirty(name, omitKey(updatedFieldArrayValues)),\n      errors: formStateRef.current.errors,\n      isValid: formStateRef.current.isValid\n    });\n  };\n\n  const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => {\n    const rootName = \"\".concat(parentName || name, \".\").concat(parentName ? valueIndex : index + valueIndex);\n    isPrimitive(appendValueItem) ? register(rootName, {\n      value: appendValueItem\n    }) : Object.entries(appendValueItem).forEach(([key, value]) => {\n      const inputName = rootName + '.' + key;\n      Array.isArray(value) ? registerFieldArray(value, valueIndex, inputName) : register(inputName, {\n        value\n      });\n    });\n  });\n\n  const append$1 = (value, options) => {\n    const appendValue = convertToArrayPayload(value);\n    const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\n    const currentIndex = updatedFieldArrayValues.length - appendValue.length;\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(append, {\n      argA: fillEmptyArray(value)\n    }, updatedFieldArrayValues, false);\n    registerFieldArray(appendValue, currentIndex);\n    focusNameRef.current = getFocusFieldName(currentIndex, options);\n  };\n\n  const prepend$1 = (value, options) => {\n    const prependValue = convertToArrayPayload(value);\n    const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(prepend, {\n      argA: fillEmptyArray(value)\n    }, updatedFieldArrayValues);\n    registerFieldArray(prependValue);\n    focusNameRef.current = getFocusFieldName(0, options);\n  };\n\n  const remove = index => {\n    const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(removeArrayAt, {\n      argA: index\n    }, updatedFieldArrayValues);\n  };\n\n  const insert$1 = (index, value, options) => {\n    const insertValue = convertToArrayPayload(value);\n    const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: fillEmptyArray(value)\n    }, updatedFieldArrayValues);\n    registerFieldArray(insertValue, index);\n    focusNameRef.current = getFocusFieldName(index, options);\n  };\n\n  const swap = (indexA, indexB) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB\n    }, fieldValues, false);\n    setFieldsAndNotify(fieldValues);\n  };\n\n  const move = (from, to) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    setFieldsAndNotify(fieldValues);\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to\n    }, fieldValues, false);\n  };\n\n  const update = (index, value) => {\n    setValues(name + '.' + index, value, {\n      shouldValidate: !!readFormStateRef.current.isValid,\n      shouldDirty: !!(readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty)\n    });\n    const fieldValues = getCurrentFieldsValues();\n    fieldValues[index] = value;\n    setFieldsAndNotify(fieldValues);\n  };\n\n  React.useEffect(() => {\n    inFieldArrayActionRef.current = false;\n\n    if (namesRef.current.watchAll) {\n      subjectsRef.current.state.next({});\n    } else {\n      for (const watchField of namesRef.current.watch) {\n        if (name.startsWith(watchField)) {\n          subjectsRef.current.state.next({});\n          break;\n        }\n      }\n    }\n\n    subjectsRef.current.watch.next({\n      name,\n      values: getFieldsValues(fieldsRef)\n    });\n    focusNameRef.current && focusFieldBy(fieldsRef.current, key => key.startsWith(focusNameRef.current));\n    focusNameRef.current = '';\n    subjectsRef.current.array.next({\n      name,\n      values: omitKey([...fields])\n    });\n    readFormStateRef.current.isValid && updateIsValid();\n  }, [fields, name]);\n  React.useEffect(() => {\n    const fieldArraySubscription = subjectsRef.current.array.subscribe({\n      next({\n        name: inputFieldArrayName,\n        values,\n        isReset\n      }) {\n        if (isReset) {\n          unset(fieldsRef.current, inputFieldArrayName || name);\n          inputFieldArrayName ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, values) : fieldArrayDefaultValuesRef.current = values;\n          setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\n        }\n      }\n\n    });\n    !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\n    isMountedRef.current = true;\n    return () => {\n      fieldArraySubscription.unsubscribe();\n\n      if (shouldUnmount || shouldUnregister) {\n        unregister(name);\n        unset(fieldArrayDefaultValuesRef.current, name);\n      } else {\n        const fieldArrayValues = get(getFieldsValues(fieldsRef), name);\n        fieldArrayValues && set(fieldArrayDefaultValuesRef.current, name, fieldArrayValues);\n      }\n    };\n  }, []);\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend$1, [name]),\n    append: React.useCallback(append$1, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert$1, [name]),\n    update: React.useCallback(update, [name]),\n    fields: fields\n  };\n};\n\nvar isFileInput = element => element.type === 'file';\n\nvar isMultipleSelect = element => element.type === \"select-multiple\";\n\nvar isRadioInput = element => element.type === 'radio';\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.checked && !option.disabled).map(option => option.value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    return options[0].checked && !options[0].disabled ? // @ts-expect-error expected to work in the browser\n    options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === '' ? validResult : {\n      value: options[0].value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nvar getFieldValueAs = (value, {\n  valueAsNumber,\n  valueAsDate,\n  setValueAs\n}) => isUndefined(value) ? value : valueAsNumber ? value === '' ? NaN : +value : valueAsDate ? new Date(value) : setValueAs ? setValueAs(value) : value;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nconst defaultReturn = {\n  isValid: false,\n  value: null\n};\n\nvar getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {\n  isValid: true,\n  value: option.value\n} : previous, defaultReturn) : defaultReturn;\n\nfunction getFieldValue(field) {\n  if (field && field._f) {\n    const ref = field._f.ref;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\n  }\n}\n\nvar getResolverOptions = (fieldsNames, fieldsRefs, criteriaMode, shouldUseNativeValidation) => {\n  const fields = {};\n\n  for (const name of fieldsNames) {\n    const field = get(fieldsRefs, name);\n    field && set(fields, name, field._f);\n  }\n\n  return {\n    criteriaMode,\n    names: [...fieldsNames],\n    fields,\n    shouldUseNativeValidation\n  };\n};\n\nvar hasValidation = (options, mounted) => mounted && options && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\n\nvar skipValidation = ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isString = value => typeof value === 'string';\n\nvar isMessage = value => isString(value) || React.isValidElement(value);\n\nvar isRegex = value => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\n  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar getValueAndMessage = validationData => isObject(validationData) && !isRegex(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar validateField = async ({\n  _f: {\n    ref,\n    refs,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n    name,\n    value: inputValue,\n    valueAsNumber,\n    mount\n  }\n}, validateAllFieldCriteria, shouldUseNativeValidation) => {\n  if (!mount) {\n    return {};\n  }\n\n  const inputRef = refs ? refs[0] : ref;\n\n  const setCustomValidty = message => {\n    if (shouldUseNativeValidation && inputRef.reportValidity) {\n      inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');\n      inputRef.reportValidity();\n    }\n  };\n\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = (valueAsNumber || isFileInput(ref)) && !ref.value || inputValue === '' || Array.isArray(inputValue) && !inputValue.length;\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, appendErrorsCurry(exceedMax ? maxType : minType, message));\n  };\n\n  if (required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n    const _ref5 = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required),\n          value = _ref5.value,\n          message = _ref5.message;\n\n    if (value) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: inputRef\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n      if (!validateAllFieldCriteria) {\n        setCustomValidty(message);\n        return error;\n      }\n    }\n  }\n\n  if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(inputValue)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\n\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(inputValue);\n\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        setCustomValidty(error[name].message);\n        return error;\n      }\n    }\n  }\n\n  if ((maxLength || minLength) && !isEmpty && isString(inputValue)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;\n    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n\n      if (!validateAllFieldCriteria) {\n        setCustomValidty(error[name].message);\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty && isString(inputValue)) {\n    const _getValueAndMessage = getValueAndMessage(pattern),\n          patternValue = _getValueAndMessage.value,\n          message = _getValueAndMessage.message;\n\n    if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\n\n      if (!validateAllFieldCriteria) {\n        setCustomValidty(message);\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    if (isFunction(validate)) {\n      const result = await validate(inputValue);\n      const validateError = getValidateError(result, inputRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          setCustomValidty(validateError.message);\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const key in validate) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateError = getValidateError((await validate[key](inputValue)), inputRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n          setCustomValidty(validateError.message);\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: inputRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  setCustomValidty(true);\n  return error;\n};\n\nvar getValidationModes = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\n  constructor() {\n    this.tearDowns = [];\n  }\n\n  add(tearDown) {\n    this.tearDowns.push(tearDown);\n  }\n\n  unsubscribe() {\n    for (const teardown of this.tearDowns) {\n      teardown();\n    }\n\n    this.tearDowns = [];\n  }\n\n}\n\nclass Subscriber {\n  constructor(observer, subscription) {\n    this.observer = observer;\n    this.closed = false;\n    subscription.add(() => this.closed = true);\n  }\n\n  next(value) {\n    if (!this.closed) {\n      this.observer.next(value);\n    }\n  }\n\n}\n\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  next(value) {\n    for (const observer of this.observers) {\n      observer.next(value);\n    }\n  }\n\n  subscribe(observer) {\n    const subscription = new Subscription();\n    const subscriber = new Subscriber(observer, subscription);\n    this.observers.push(subscriber);\n    return subscription;\n  }\n\n  unsubscribe() {\n    this.observers = [];\n  }\n\n}\n\nconst isWindowUndefined = typeof window === 'undefined';\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUseNativeValidation,\n  shouldUnregister,\n  criteriaMode\n} = {}) {\n  const _React$useState7 = React.useState({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: false,\n    errors: {}\n  }),\n        _React$useState8 = _slicedToArray(_React$useState7, 2),\n        formState = _React$useState8[0],\n        updateFormState = _React$useState8[1];\n\n  const readFormStateRef = React.useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled\n  });\n  const resolverRef = React.useRef(resolver);\n  const formStateRef = React.useRef(formState);\n  const fieldsRef = React.useRef({});\n  const defaultValuesRef = React.useRef(defaultValues);\n  const fieldArrayDefaultValuesRef = React.useRef({});\n  const contextRef = React.useRef(context);\n  const inFieldArrayActionRef = React.useRef(false);\n  const isMountedRef = React.useRef(false);\n  const subjectsRef = React.useRef({\n    watch: new Subject(),\n    control: new Subject(),\n    array: new Subject(),\n    state: new Subject()\n  });\n  const namesRef = React.useRef({\n    mount: new Set(),\n    unMount: new Set(),\n    array: new Set(),\n    watch: new Set(),\n    watchAll: false\n  });\n  const validationMode = getValidationModes(mode);\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  resolverRef.current = resolver;\n  contextRef.current = context;\n\n  const isFieldWatched = name => namesRef.current.watchAll || namesRef.current.watch.has(name) || namesRef.current.watch.has((name.match(/\\w+/) || [])[0]);\n\n  const shouldRenderBaseOnError = React.useCallback(async (shouldSkipRender, name, error, inputState, isValidFromResolver, isWatched) => {\n    const previousError = get(formStateRef.current.errors, name);\n    const isValid = readFormStateRef.current.isValid ? resolver ? isValidFromResolver : await validateForm(fieldsRef.current, true) : false;\n    error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n\n    if ((isWatched || (error ? !deepEqual(previousError, error, true) : previousError) || !isEmptyObject(inputState) || formStateRef.current.isValid !== isValid) && !shouldSkipRender) {\n      const updatedFormState = Object.assign(Object.assign({}, inputState), {\n        isValid: !!isValid,\n        errors: formStateRef.current.errors,\n        name\n      });\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\n      subjectsRef.current.state.next(isWatched ? {\n        name\n      } : updatedFormState);\n    }\n\n    subjectsRef.current.state.next({\n      isValidating: false\n    });\n  }, []);\n  const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\n    shouldRegister && register(name);\n    const field = get(fieldsRef.current, name);\n\n    if (field) {\n      const _f = field._f;\n\n      if (_f) {\n        const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n        _f.value = getFieldValueAs(rawValue, _f);\n\n        if (isRadioInput(_f.ref)) {\n          (_f.refs || []).forEach(radioRef => radioRef.checked = radioRef.value === value);\n        } else if (isFileInput(_f.ref) && !isString(value)) {\n          _f.ref.files = value;\n        } else if (isMultipleSelect(_f.ref)) {\n          [..._f.ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n        } else if (isCheckBoxInput(_f.ref) && _f.refs) {\n          _f.refs.length > 1 ? _f.refs.forEach(checkboxRef => checkboxRef.checked = Array.isArray(value) ? !!value.find(data => data === checkboxRef.value) : value === checkboxRef.value) : _f.refs[0].checked = !!value;\n        } else {\n          _f.ref.value = value;\n        }\n\n        if (shouldRender) {\n          const values = getFieldsValues(fieldsRef);\n          set(values, name, rawValue);\n          subjectsRef.current.control.next({\n            values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\n            name\n          });\n        }\n\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirtyState(name, value, options.shouldTouch);\n        options.shouldValidate && trigger(name);\n      } else {\n        field._f = {\n          ref: {\n            name,\n            value: rawValue\n          },\n          value: rawValue\n        };\n      }\n    }\n  }, []);\n  const getIsDirty = React.useCallback((name, data) => {\n    const formValues = getFieldsValues(fieldsRef);\n    name && data && set(formValues, name, data);\n    return !deepEqual(formValues, defaultValuesRef.current);\n  }, []);\n  const updateTouchAndDirtyState = React.useCallback((name, inputValue, isCurrentTouched, shouldRender = true) => {\n    const state = {\n      name\n    };\n    let isChanged = false;\n\n    if (readFormStateRef.current.isDirty) {\n      const previousIsDirty = formStateRef.current.isDirty;\n      formStateRef.current.isDirty = getIsDirty();\n      state.isDirty = formStateRef.current.isDirty;\n      isChanged = previousIsDirty !== state.isDirty;\n    }\n\n    if (readFormStateRef.current.dirtyFields && !isCurrentTouched) {\n      const isPreviousFieldDirty = get(formStateRef.current.dirtyFields, name);\n      const isCurrentFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\n      isCurrentFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      state.dirtyFields = formStateRef.current.dirtyFields;\n      isChanged = isChanged || isPreviousFieldDirty !== get(formStateRef.current.dirtyFields, name);\n    }\n\n    const isPreviousFieldTouched = get(formStateRef.current.touchedFields, name);\n\n    if (isCurrentTouched && !isPreviousFieldTouched) {\n      set(formStateRef.current.touchedFields, name, isCurrentTouched);\n      state.touchedFields = formStateRef.current.touchedFields;\n      isChanged = isChanged || readFormStateRef.current.touchedFields && isPreviousFieldTouched !== isCurrentTouched;\n    }\n\n    isChanged && shouldRender && subjectsRef.current.state.next(state);\n    return isChanged ? state : {};\n  }, []);\n  const executeInlineValidation = React.useCallback(async (name, skipReRender) => {\n    const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria, shouldUseNativeValidation))[name];\n    await shouldRenderBaseOnError(skipReRender, name, error);\n    return isUndefined(error);\n  }, [isValidateAllFieldCriteria]);\n  const executeResolverValidation = React.useCallback(async names => {\n    const _ref6 = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, getResolverOptions(namesRef.current.mount, fieldsRef.current, criteriaMode, shouldUseNativeValidation)),\n          errors = _ref6.errors;\n\n    if (names) {\n      for (const name of names) {\n        const error = get(errors, name);\n        error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n      }\n    } else {\n      formStateRef.current.errors = errors;\n    }\n\n    return errors;\n  }, [criteriaMode, shouldUseNativeValidation]);\n\n  const validateForm = async (fieldsRef, shouldCheckValid, context = {\n    valid: true\n  }) => {\n    for (const name in fieldsRef) {\n      const field = fieldsRef[name];\n\n      if (field) {\n        const _f = field._f;\n        const current = omit(field, '_f');\n\n        if (_f) {\n          const fieldError = await validateField(field, isValidateAllFieldCriteria, shouldUseNativeValidation);\n\n          if (shouldCheckValid) {\n            if (fieldError[_f.name]) {\n              context.valid = false;\n              break;\n            }\n          } else {\n            fieldError[_f.name] ? set(formStateRef.current.errors, _f.name, fieldError[_f.name]) : unset(formStateRef.current.errors, _f.name);\n          }\n        }\n\n        current && (await validateForm(current, shouldCheckValid, context));\n      }\n    }\n\n    return context.valid;\n  };\n\n  const trigger = React.useCallback(async (name, options = {}) => {\n    const fieldNames = convertToArrayPayload(name);\n    let isValid;\n    subjectsRef.current.state.next({\n      isValidating: true\n    });\n\n    if (resolver) {\n      const schemaResult = await executeResolverValidation(isUndefined(name) ? name : fieldNames);\n      isValid = name ? fieldNames.every(name => !get(schemaResult, name)) : isEmptyObject(schemaResult);\n    } else {\n      if (name) {\n        isValid = (await Promise.all(fieldNames.filter(fieldName => get(fieldsRef.current, fieldName, {})._f).map(async fieldName => await executeInlineValidation(fieldName, true)))).every(Boolean);\n      } else {\n        await validateForm(fieldsRef.current);\n        isValid = isEmptyObject(formStateRef.current.errors);\n      }\n    }\n\n    subjectsRef.current.state.next(Object.assign(Object.assign({}, isString(name) ? {\n      name\n    } : {}), {\n      errors: formStateRef.current.errors,\n      isValidating: false\n    }));\n\n    if (options.shouldFocus && !isValid) {\n      focusFieldBy(fieldsRef.current, key => get(formStateRef.current.errors, key), name ? fieldNames : namesRef.current.mount);\n    }\n\n    readFormStateRef.current.isValid && updateIsValid();\n    return isValid;\n  }, [executeResolverValidation, executeInlineValidation]);\n\n  const updateIsValidAndInputValue = (name, ref) => {\n    const field = get(fieldsRef.current, name);\n\n    if (field) {\n      const isValueUndefined = isUndefined(field._f.value);\n      const defaultValue = isValueUndefined ? isUndefined(get(fieldArrayDefaultValuesRef.current, name)) ? get(defaultValuesRef.current, name) : get(fieldArrayDefaultValuesRef.current, name) : field._f.value;\n\n      if (!isUndefined(defaultValue)) {\n        if (ref && ref.defaultChecked) {\n          field._f.value = getFieldValue(field);\n        } else {\n          setFieldValue(name, defaultValue);\n        }\n      } else if (isValueUndefined) {\n        field._f.value = getFieldValue(field);\n      }\n    }\n\n    isMountedRef.current && readFormStateRef.current.isValid && updateIsValid();\n  };\n\n  const updateIsValid = React.useCallback(async (values = {}) => {\n    const isValid = resolver ? isEmptyObject((await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef)), values), contextRef.current, getResolverOptions(namesRef.current.mount, fieldsRef.current, criteriaMode, shouldUseNativeValidation))).errors) : await validateForm(fieldsRef.current, true);\n    isValid !== formStateRef.current.isValid && subjectsRef.current.state.next({\n      isValid\n    });\n  }, [criteriaMode, shouldUseNativeValidation]);\n  const setValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([fieldKey, fieldValue]) => {\n    const fieldName = \"\".concat(name, \".\").concat(fieldKey);\n    const field = get(fieldsRef.current, fieldName);\n    const isFieldArray = namesRef.current.array.has(name);\n    (isFieldArray || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options, true, !field);\n  }), [trigger]);\n\n  const setValue = (name, value, options = {}) => {\n    const field = get(fieldsRef.current, name);\n    const isFieldArray = namesRef.current.array.has(name);\n\n    if (isFieldArray) {\n      subjectsRef.current.array.next({\n        values: value,\n        name,\n        isReset: true\n      });\n\n      if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && options.shouldDirty) {\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n        subjectsRef.current.state.next({\n          name,\n          dirtyFields: formStateRef.current.dirtyFields,\n          isDirty: getIsDirty(name, value)\n        });\n      }\n\n      !value.length && set(fieldsRef.current, name, []) && set(fieldArrayDefaultValuesRef.current, name, []);\n    }\n\n    (field && !field._f || isFieldArray) && !isNullOrUndefined(value) ? setValues(name, value, isFieldArray ? {} : options) : setFieldValue(name, value, options, true, !field);\n    isFieldWatched(name) && subjectsRef.current.state.next({});\n    subjectsRef.current.watch.next({\n      name,\n      values: getValues()\n    });\n  };\n\n  const handleChange = React.useCallback(async ({\n    type,\n    target,\n    target: {\n      value,\n      name,\n      type: inputType\n    }\n  }) => {\n    let error;\n    let isValid;\n    const field = get(fieldsRef.current, name);\n\n    if (field) {\n      let inputValue = inputType ? getFieldValue(field) : undefined;\n      inputValue = isUndefined(inputValue) ? value : inputValue;\n      const isBlurEvent = type === EVENTS.BLUR;\n\n      const _getValidationModes = getValidationModes(reValidateMode),\n            isReValidateOnBlur = _getValidationModes.isOnBlur,\n            isReValidateOnChange = _getValidationModes.isOnChange;\n\n      const shouldSkipValidation = !hasValidation(field._f, field._f.mount) && !resolver && !get(formStateRef.current.errors, name) || skipValidation(Object.assign({\n        isBlurEvent,\n        isTouched: !!get(formStateRef.current.touchedFields, name),\n        isSubmitted: formStateRef.current.isSubmitted,\n        isReValidateOnBlur,\n        isReValidateOnChange\n      }, validationMode));\n      const isWatched = !isBlurEvent && isFieldWatched(name);\n\n      if (!isUndefined(inputValue)) {\n        field._f.value = inputValue;\n      }\n\n      const inputState = updateTouchAndDirtyState(name, field._f.value, isBlurEvent, false);\n      const shouldRender = !isEmptyObject(inputState) || isWatched;\n\n      if (shouldSkipValidation) {\n        !isBlurEvent && subjectsRef.current.watch.next({\n          name,\n          type,\n          values: getValues()\n        });\n        return shouldRender && subjectsRef.current.state.next(isWatched ? {\n          name\n        } : Object.assign(Object.assign({}, inputState), {\n          name\n        }));\n      }\n\n      subjectsRef.current.state.next({\n        isValidating: true\n      });\n\n      if (resolver) {\n        const _ref7 = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, getResolverOptions([name], fieldsRef.current, criteriaMode, shouldUseNativeValidation)),\n              errors = _ref7.errors;\n\n        error = get(errors, name);\n\n        if (isCheckBoxInput(target) && !error) {\n          const parentNodeName = getNodeParentName(name);\n          const currentError = get(errors, parentNodeName, {});\n          currentError.type && currentError.message && (error = currentError);\n\n          if (currentError || get(formStateRef.current.errors, parentNodeName)) {\n            name = parentNodeName;\n          }\n        }\n\n        isValid = isEmptyObject(errors);\n      } else {\n        error = (await validateField(field, isValidateAllFieldCriteria, shouldUseNativeValidation))[name];\n      }\n\n      !isBlurEvent && subjectsRef.current.watch.next({\n        name,\n        type,\n        values: getValues()\n      });\n      shouldRenderBaseOnError(false, name, error, inputState, isValid, isWatched);\n    }\n  }, []);\n\n  const getValues = fieldNames => {\n    const values = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef));\n    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map(name => get(values, name));\n  };\n\n  const clearErrors = name => {\n    name ? convertToArrayPayload(name).forEach(inputName => unset(formStateRef.current.errors, inputName)) : formStateRef.current.errors = {};\n    subjectsRef.current.state.next({\n      errors: formStateRef.current.errors\n    });\n  };\n\n  const setError = (name, error, options) => {\n    const ref = ((get(fieldsRef.current, name) || {\n      _f: {}\n    })._f || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref\n    }));\n    subjectsRef.current.state.next({\n      name,\n      errors: formStateRef.current.errors,\n      isValid: false\n    });\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal, formValues) => {\n    const isArrayNames = Array.isArray(fieldNames);\n    const fieldValues = formValues || isMountedRef.current ? Object.assign(Object.assign({}, defaultValuesRef.current), formValues || getFieldsValues(fieldsRef)) : isUndefined(defaultValue) ? defaultValuesRef.current : isArrayNames ? defaultValue : {\n      [fieldNames]: defaultValue\n    };\n\n    if (isUndefined(fieldNames)) {\n      isGlobal && (namesRef.current.watchAll = true);\n      return fieldValues;\n    }\n\n    const result = [];\n\n    for (const fieldName of convertToArrayPayload(fieldNames)) {\n      isGlobal && namesRef.current.watch.add(fieldName);\n      result.push(get(fieldValues, fieldName));\n    }\n\n    return isArrayNames ? result : result[0];\n  }, []);\n\n  const watch = (fieldName, defaultValue) => isFunction(fieldName) ? subjectsRef.current.watch.subscribe({\n    next: info => fieldName(watchInternal(undefined, defaultValue), info)\n  }) : watchInternal(fieldName, defaultValue, true);\n\n  const unregister = (name, options = {}) => {\n    for (const inputName of name ? convertToArrayPayload(name) : namesRef.current.mount) {\n      namesRef.current.mount.delete(inputName);\n      namesRef.current.array.delete(inputName);\n\n      if (get(fieldsRef.current, inputName)) {\n        !options.keepError && unset(formStateRef.current.errors, inputName);\n        !options.keepValue && unset(fieldsRef.current, inputName);\n        !options.keepDirty && unset(formStateRef.current.dirtyFields, inputName);\n        !options.keepTouched && unset(formStateRef.current.touchedFields, inputName);\n        !shouldUnregister && !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\n      }\n    }\n\n    subjectsRef.current.watch.next({\n      values: getValues()\n    });\n    subjectsRef.current.state.next(Object.assign(Object.assign({}, formStateRef.current), !options.keepDirty ? {} : {\n      isDirty: getIsDirty()\n    }));\n    !options.keepIsValid && updateIsValid();\n  };\n\n  const registerFieldRef = (name, ref, options) => {\n    register(name, options);\n    let field = get(fieldsRef.current, name);\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n    if (ref === field._f.ref || isRadioOrCheckbox && compact(field._f.refs || []).find(option => option === ref)) {\n      return;\n    }\n\n    field = {\n      _f: isRadioOrCheckbox ? Object.assign(Object.assign({}, field._f), {\n        refs: [...compact(field._f.refs || []).filter(ref => isHTMLElement(ref) && document.contains(ref)), ref],\n        ref: {\n          type: ref.type,\n          name\n        }\n      }) : Object.assign(Object.assign({}, field._f), {\n        ref\n      })\n    };\n    set(fieldsRef.current, name, field);\n    updateIsValidAndInputValue(name, ref);\n  };\n\n  const register = React.useCallback((name, options = {}) => {\n    const field = get(fieldsRef.current, name);\n    set(fieldsRef.current, name, {\n      _f: Object.assign(Object.assign(Object.assign({}, field && field._f ? field._f : {\n        ref: {\n          name\n        }\n      }), {\n        name,\n        mount: true\n      }), options)\n    });\n    namesRef.current.mount.add(name);\n    !field && updateIsValidAndInputValue(name);\n    return isWindowUndefined ? {\n      name: name\n    } : {\n      name,\n      onChange: handleChange,\n      onBlur: handleChange,\n      ref: ref => {\n        if (ref) {\n          registerFieldRef(name, ref, options);\n        } else {\n          const field = get(fieldsRef.current, name, {});\n          const shouldUnmount = shouldUnregister || options.shouldUnregister;\n\n          if (field._f) {\n            field._f.mount = false; // If initial state of field element is disabled,\n            // value is not set on first \"register\"\n            // re-sync the value in when it switched to enabled\n\n            if (isUndefined(field._f.value)) {\n              field._f.value = field._f.ref.value;\n            }\n          }\n\n          shouldUnmount && !(isNameInFieldArray(namesRef.current.array, name) && inFieldArrayActionRef.current) && namesRef.current.unMount.add(name);\n        }\n      }\n    };\n  }, []);\n  const handleSubmit = React.useCallback((onValid, onInvalid) => async e => {\n    if (e) {\n      e.preventDefault && e.preventDefault();\n      e.persist && e.persist();\n    }\n\n    let hasNoPromiseError = true;\n    let fieldValues = getFieldsValues(fieldsRef);\n    subjectsRef.current.state.next({\n      isSubmitting: true\n    });\n\n    try {\n      if (resolver) {\n        const _ref8 = await resolverRef.current(fieldValues, contextRef.current, getResolverOptions(namesRef.current.mount, fieldsRef.current, criteriaMode, shouldUseNativeValidation)),\n              errors = _ref8.errors,\n              values = _ref8.values;\n\n        formStateRef.current.errors = errors;\n        fieldValues = values;\n      } else {\n        await validateForm(fieldsRef.current);\n      }\n\n      if (isEmptyObject(formStateRef.current.errors) && Object.keys(formStateRef.current.errors).every(name => get(fieldValues, name))) {\n        subjectsRef.current.state.next({\n          errors: {},\n          isSubmitting: true\n        });\n        await onValid(fieldValues, e);\n      } else {\n        onInvalid && (await onInvalid(formStateRef.current.errors, e));\n        shouldFocusError && focusFieldBy(fieldsRef.current, key => get(formStateRef.current.errors, key), namesRef.current.mount);\n      }\n    } catch (err) {\n      hasNoPromiseError = false;\n      throw err;\n    } finally {\n      formStateRef.current.isSubmitted = true;\n      subjectsRef.current.state.next({\n        isSubmitted: true,\n        isSubmitting: false,\n        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors) && hasNoPromiseError,\n        submitCount: formStateRef.current.submitCount + 1,\n        errors: formStateRef.current.errors\n      });\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode, shouldUseNativeValidation]);\n\n  const registerAbsentFields = (defaultValues, name = '') => {\n    for (const key in defaultValues) {\n      const value = defaultValues[key];\n      const fieldName = name + (name ? '.' : '') + key;\n      const field = get(fieldsRef.current, fieldName);\n\n      if (!field || !field._f) {\n        if (isObject(value) || Array.isArray(value)) {\n          registerAbsentFields(value, fieldName);\n        } else if (!field) {\n          register(fieldName, {\n            value\n          });\n        }\n      }\n    }\n  };\n\n  const reset = (values, keepStateOptions = {}) => {\n    const updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (const name of namesRef.current.mount) {\n        const field = get(fieldsRef.current, name);\n\n        if (field && field._f) {\n          const inputRef = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n\n          try {\n            isHTMLElement(inputRef) && inputRef.closest('form').reset();\n            break;\n          } catch (_a) {}\n        }\n      }\n    }\n\n    if (!keepStateOptions.keepDefaultValues) {\n      defaultValuesRef.current = Object.assign({}, updatedValues);\n      fieldArrayDefaultValuesRef.current = Object.assign({}, updatedValues);\n    }\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n      subjectsRef.current.control.next({\n        values: keepStateOptions.keepDefaultValues ? defaultValuesRef.current : Object.assign({}, updatedValues)\n      });\n      subjectsRef.current.watch.next({\n        values: Object.assign({}, updatedValues)\n      });\n      subjectsRef.current.array.next({\n        values: Object.assign({}, updatedValues),\n        isReset: true\n      });\n    }\n\n    namesRef.current = {\n      mount: new Set(),\n      unMount: new Set(),\n      array: new Set(),\n      watch: new Set(),\n      watchAll: false\n    };\n    subjectsRef.current.state.next({\n      submitCount: keepStateOptions.keepSubmitCount ? formStateRef.current.submitCount : 0,\n      isDirty: keepStateOptions.keepDirty ? formStateRef.current.isDirty : keepStateOptions.keepDefaultValues ? deepEqual(values, defaultValuesRef.current) : false,\n      isSubmitted: keepStateOptions.keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n      dirtyFields: keepStateOptions.keepDirty ? formStateRef.current.dirtyFields : {},\n      touchedFields: keepStateOptions.keepTouched ? formStateRef.current.touchedFields : {},\n      errors: keepStateOptions.keepErrors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n    isMountedRef.current = !!keepStateOptions.keepIsValid;\n  };\n\n  const setFocus = name => get(fieldsRef.current, name)._f.ref.focus();\n\n  React.useEffect(() => {\n    const formStateSubscription = subjectsRef.current.state.subscribe({\n      next(formState) {\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\n          updateFormState(formStateRef.current);\n        }\n      }\n\n    });\n    const useFieldArraySubscription = subjectsRef.current.array.subscribe({\n      next(state) {\n        if (state.values && state.name && readFormStateRef.current.isValid) {\n          const values = getFieldsValues(fieldsRef);\n          set(values, state.name, state.values);\n          updateIsValid(values);\n        }\n      }\n\n    });\n    return () => {\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n  React.useEffect(() => {\n    const unregisterFieldNames = [];\n\n    const isLiveInDom = ref => !isHTMLElement(ref) || !document.contains(ref);\n\n    if (!isMountedRef.current) {\n      isMountedRef.current = true;\n      readFormStateRef.current.isValid && updateIsValid();\n      !shouldUnregister && registerAbsentFields(defaultValuesRef.current);\n    }\n\n    for (const name of namesRef.current.unMount) {\n      const field = get(fieldsRef.current, name);\n      field && (field._f.refs ? field._f.refs.every(isLiveInDom) : isLiveInDom(field._f.ref)) && unregisterFieldNames.push(name);\n    }\n\n    unregisterFieldNames.length && unregister(unregisterFieldNames);\n    namesRef.current.unMount = new Set();\n  });\n  return {\n    control: React.useMemo(() => ({\n      register,\n      inFieldArrayActionRef,\n      getIsDirty,\n      subjectsRef,\n      watchInternal,\n      fieldsRef,\n      updateIsValid,\n      namesRef,\n      readFormStateRef,\n      formStateRef,\n      defaultValuesRef,\n      fieldArrayDefaultValuesRef,\n      setValues,\n      unregister,\n      shouldUnmount: shouldUnregister\n    }), []),\n    formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\n    trigger,\n    register,\n    handleSubmit,\n    watch: React.useCallback(watch, []),\n    setValue: React.useCallback(setValue, [setValues]),\n    getValues: React.useCallback(getValues, []),\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    unregister: React.useCallback(unregister, []),\n    setError: React.useCallback(setError, []),\n    setFocus: React.useCallback(setFocus, [])\n  };\n}\n\nfunction useWatch(props) {\n  const _ref9 = props || {},\n        control = _ref9.control,\n        name = _ref9.name,\n        defaultValue = _ref9.defaultValue;\n\n  const methods = useFormContext();\n  const nameRef = React.useRef(name);\n  nameRef.current = name;\n\n  const _ref10 = control || methods.control,\n        watchInternal = _ref10.watchInternal,\n        subjectsRef = _ref10.subjectsRef;\n\n  const _React$useState9 = React.useState(isUndefined(defaultValue) ? watchInternal(name) : defaultValue),\n        _React$useState10 = _slicedToArray(_React$useState9, 2),\n        value = _React$useState10[0],\n        updateValue = _React$useState10[1];\n\n  React.useEffect(() => {\n    watchInternal(name);\n    const watchSubscription = subjectsRef.current.watch.subscribe({\n      next: ({\n        name: inputName,\n        values\n      }) => (!nameRef.current || !inputName || convertToArrayPayload(nameRef.current).some(fieldName => inputName && fieldName && (fieldName.startsWith(inputName) || inputName.startsWith(fieldName)))) && updateValue(watchInternal(nameRef.current, defaultValue, false, values))\n    });\n    return () => watchSubscription.unsubscribe();\n  }, []);\n  return value;\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };","map":null,"metadata":{},"sourceType":"module"}